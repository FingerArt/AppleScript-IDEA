{

  parserClass="com.intellij.plugin.applescript.lang.parser.AppleScriptParser"
  psiImplUtilClass="com.intellij.plugin.applescript.psi.impl.AppleScriptPsiImplUtil"

  parserUtilClass="com.intellij.plugin.applescript.lang.parser.AppleScriptGeneratedParserUtil" //for external grammar

    extends="com.intellij.plugin.applescript.psi.impl.AppleScriptPsiElementImpl"
    implements="com.intellij.plugin.applescript.psi.AppleScriptPsiElement"

    psiClassPrefix="AppleScript"
    psiImplClassSuffix="Impl"
    psiPackage="com.intellij.plugin.applescript.psi"
    psiImplPackage="com.intellij.plugin.applescript.psi.impl"

    elementTypeHolderClass="com.intellij.plugin.applescript.psi.AppleScriptTypes"
    elementTypeClass="com.intellij.plugin.applescript.lang.parser.AppleScriptElementType"
    tokenTypeClass="com.intellij.plugin.applescript.lang.lexer.AppleScriptTokenType"
    tokens = [

  // NewLines and spaces //
  //  NLS ='regexp:{ONE_NL}({ONE_NL}|{WHITE_SPACE})*'
    NLS ='regexp:(\r|\n|\r\n)( (\r|\n|\r\n)|([\ \t\f]) )*'
    mONE_NL = 'regexp:(\r|\n|\r\n)'                                   // NewLines

    LPAREN='('
    RPAREN=')'

  // containment
  //list,string
    STARTS_BEGINS_WITH='regexp:(starts? with)|(begins? with)'
    ENDS_WITH='regexp:ends? with'
    //list,record,string
    DOES_NOT_CONTAIN="regexp:(does not contain)|(doesn't contain)"
    IS_IN="regexp:(is in)|(is contained by)"
    IS_NOT_IN="regexp:(is not in)|(is not contained by)|(isn't contained by)"
    IS_CONTAIN="regexp:(contain|contains)"

    // comparison operators
    GT="regexp:(>|((is)? greater than)|(comes after)|(is not less than or equal (to)?)|(isn't less than or equal (to)?))"
    LE="regexp:(≤|<=|((is)? less than or equal (to)?)|(is not greater than)|(isn't greater than)|(does not come after)|(doesn't come after))"
    GE="regexp:(≥|>=|((is)? greater than or equal (to)?)|(is not less than)|(isn't less than)|(does not come before)|(doesn't come before))"
    LT="regexp:(<|((is)? less than)|(comes before)|(is not greater than or equal (to)?)|(isn't greater than or equal (to)?))"
    NE="regexp:(≠|(isn't equal (to)?)|(is not equal (to)?)|(doesn't equal)|(does not equal)|(is not)|(isn't))"
    EQ="regexp:(=|((is)? equal to)|is|equal|equals)"
    REF_OP="regexp:(a reference to|a ref to|a ref|reference to|ref)"

    CC='¬'
    PLUS='+'
    MINUS='-'
    STAR='*'
    DIV='regexp:(/|÷)'
    INT_DIV='div'
    MOD='mod'
    POW='^'
    LOR='or'
    LAND='and'
    BAND='&'
    LNOT='not'
    AS='as'
    APS="'s"

    //built in types
    //==> builtInClassIdCommon ==>
    STRING='string'
    CLASS='class'
    CONSTANT='constant'
    LIST='list'
    DATA='data'
    REFERENCE='reference'
    STYLED_TEXT='regexp:styled[\ \t\f]+text'
    TEXT_ITEM='regexp:text[\ \t\f]+item'
    ITEM='item'
    FILE_SPECIFICATION='regexp:file[\ \t\f]+specification'
    INTERNATIONAL_TEXT='regexp:international[\ \t\f]+text'
    UNICODE_TEXT='regexp:unicode[\ \t\f]+text'
    RGB_COLOR='regexp:rgb[\ \t\f]+color'
    STYLED_CLIPBOARD_TEXT='regexp:styled[\ \t\f]+clipboard[\ \t\f]+text'
    //==> statement tokens
    REPEAT='repeat'
    //==> builtInClassIdNative ==>
    ANY='any'
    BOOLEAN='boolean'
    DATE='date'
    FILE='file'
    ALIAS='alias'
    INTEGER='integer'
    LOCATION_SPECIFIER='regexp:location[\ \t\f]+specifier'
    NUMBER='number'
    POINT='point'
    REAL='real'
    RECORD='record'
    RECTANGLE='rectangle'
    SPECIFIER='specifier'
    TEXT='text'
    TYPE='type'
    //==> UNIT_TYPE_VALUE_CLASSES ==>
    GALLONS='gallons'
    LITRES='litres'
    LITERS='liters'
    QUARTS='quarts'

    GRAMS='grams'
    KILOGRAMS='kilograms'
    OUNCES='ounces'
    POUNDS='pounds'

    TEMPERATURE='regexp:degrees[\ \t\f]+(Celsius|Fahrenheit|Kelvin)'
    CUBIC_VOL='regexp:cubic[\ \t\f]+(centimetres|centimeters|feet|inches|metres|meters|yards)'
    SQUARE_AREA='regexp:square[\ \t\f]+(feet|kilometres|kilometers|metres|meters|miles|yards)'

    CENTIMETRES='centimetres'
    CENTIMETERS='centimeters'
    FEET='feet'
    INCHES='inches'
    KILOMETRES='kilometres'
    KILOMETERS='kilometers'
    METRES='metres'
    METERS='meters'
    MILES='miles'
    YARDS='yards'

    BUILT_IN_TYPE_S='regexp:(string|integer|real|boolean|class|constant|list|record|data|date|number|reference|styled text|text item|text|item)s'

    //todo not only for literals
    //==>built in properties==>
    BUILT_IN_PROPERTY='regexp:("class"|day|weekday|month|year|time|date string|time string|(quoted[\ \t\f]+form)|length|rest|reverse|contents)'
    //properties of standard classes
    //string
    QUOTED_FORM='regexp:quoted[\ \t\f]+form'

    //some keywords here which do not appear in rules distinctively
    THE_KW='the'
    DOES='does'
    APART_FROM='regexp:apart[\ \t\f]+from'
    ASIDE_FROM='regexp:aside[\ \t\f]+from'
    OUT_OF='regexp:out[\ \t\f]+of'
    INSTEAD_OF='regexp:instead[\ \t\f]+of'
    THAT='that'
    REFERENCE='reference'
//    ITS='its'
    C_WHITE_SPACE='regexp:(white[\ \t\f]+space)'
    APP_RESPONSES='regexp:((application[\ \t\f]+responses)|(app[\ \t\f]+responses))'
    SCRIPTING_ADDITIONS='regexp:scripting[\ \t\f]+additions'
    CURRENT_APPLICATION='regexp:current[\ \t\f]+application'
    CURRENT_APP='regexp:current[\ \t\f]+app'
    CURRENT='current'
    APPLICATION='application'
    APP='app'
    TEXT_ITEM_DELIMETERS='regexp:text[\ \t\f]+item[\ \t\f]+delimiters'
    MISSING_VALUE='regexp:missing[\ \t\f]+value'

    //constants
    PI_CONSTANT='pi'              //3.1412926
    MINUTES_CONSTANT='minutes'    // =60seconds
    HOURS_CONSTANT='hours'        //60*60
    DAYS_CONSTANT='days'          //60*60*24
    WEEKS_CONSTANT='weeks'

    STRING_LITERAL='regexp:"([^"\\]|\\.)*"'
    DIGITS='regexp:[0-9]+'

    DEC_EXPONENT='regexp:[Ee][+-]?[0-9]+'
    var_identifier='regexp:([_a-zA-Z][a-zA-Z0-9_]*)|(\|(([^\|])|(\\\|))*[^\\]\|)'
  //todo nested comments (in a lexer with the states...)
    COMMENT='regexp:((#.*)|(--.*)|((\(\*[^\*](([^\*]*(\*+[^\*\)])?)*(\*+\))?))|\(\*))'
    RAW_CODE='regexp:(<<[^>>]*>>)'
    MULTI_LINE_COMMENT_START='(*'
    MULTI_LINE_COMMENT_END='*)'
    WHITE_SPACE='regexp:[\ \t\f]'
    COMMA=','
    LCURLY='{'
    RCURLY='}'
    COLON=':'


  ]
    extends(".*Expression")="expression"
    consumeTokenMethod(".*(Expression|Recover|Condition)")="consumeTokenFast"
}

appleScriptFile ::= compilation_unit_*

private compilation_unit_ ::= topBlockBodyPart|sep

private topBlockBodyPart ::= topLevelStatement | statement | expression | RAW_CODE | incompleteExpression
{recoverWhile=topBodyPartRecover}
private topBodyPartRecover ::= !(sep/*|tell*/)

private sep ::= (COMMENT? NLS COMMENT?)+ // one or more new lines and spaces

scriptBody ::= topBlockBodyPart (sep topBlockBodyPart)* sep?
{pin=1}

incompleteExpression ::= tell expression | set objectReferenceWrapper | copy expression | if expression

identifier ::= var_identifier

referenceIdentifier ::= identifier
{mixin="com.intellij.plugin.applescript.psi.impl.AppleScriptReferenceElementImpl"
 implements="com.intellij.plugin.applescript.psi.AppleScriptReferenceElement"}

private topLevelStatement ::= applicationHandlerDefinition|userHandlerDefinition | <<parseUseStatement useStatement>>
private statement ::= controlStatement|propertyDeclarationStatement|varDeclarationList
                      |scriptObjectDefinition
                      |scriptObjectUnnamedDefinition
                      |returnStatement|continue_statement
                      |parseAssignmentStatement


private userHandlerDefinition ::= handlerLabeledParametersDefinition|handlerPositionalParametersDefinition
                      |handlerRunDefinition|handlerOpenDefinition//|handlerIdleDefinition|handlerQuitDefinition
                      |handlerInterleavedParametersDefinition
returnStatement ::= return [expression]

private controlStatement ::= ifStatement | tryStatement | tellStatement | <<parseExpression '"repeat"' repeatStatement>>
| exitStatement | consideringStatement | ignoringStatement | withTimeoutStatement | withTransactionStatement
| <<parseUsingTermsFromStatement>>

exitStatement ::= exit [REPEAT]
private repeatStatement ::= repeatNumTimesStatement | repeatWhileStatement | repeatUntilStatement
| repeatWithRangeStatement | repeatWithListStatement | repeatForeverStatement

topBlockBody ::= topBlockBodyPart sep (topBlockBodyPart sep)*
{pin=1}
blockBody ::= blockBodyPart sep ( blockBodyPart sep)*
{pin=1}
//private bodyRecover ::= !((end|(on error)|else))

private blockBodyPart ::= statement|expression|RAW_CODE
{recoverWhile=bodyPartRecover}
private bodyPartRecover ::= !(sep)

repeatForeverStatement ::= REPEAT sep
                            blockBody?
                           end [REPEAT]

repeatNumTimesStatement ::= REPEAT numTimes [times] sep
                            blockBody?
                            end [REPEAT]

private numTimes ::= expression//integerLiteralExpression|referenceIdentifier|parenthesizedExpression

repeatWhileStatement ::= REPEAT while expression sep
                            blockBody?
                         end [REPEAT] {pin=2}

repeatUntilStatement ::= REPEAT until expression sep
                         blockBody?
                         end [REPEAT] {pin=2}

repeatWithRangeStatement ::= REPEAT with loopVariable from startValue to stopValue [by stepValue] sep
                             blockBody?
                             end [REPEAT] {pin=4}

//todo expression does not always work.. (because of 'to' )
private stepValue ::= expression
private stopValue ::= (referenceIdentifier &by) | expression
private startValue ::= (referenceIdentifier &to) | expression
private loopVariable ::= directParameterDeclaration

repeatWithListStatement ::= REPEAT with loopVariable in listOrReferenceExpression sep
                         blockBody?
                         end [REPEAT] {pin=4}
private listOrReferenceExpression ::= expression

errorCommandExpression ::= error [errorMessage] [number errorNumber]
                                 [from offendingObject]
                                 [to expectedType]
                                 [partial result resultList]
private resultList ::= expression
private offendingObject ::= (referenceIdentifier &to) | expression
private expectedType ::= expression
private errorNumber ::= expression
private errorMessage ::= expression

tryStatement ::= try sep
                     blockBody?
                     (on error [errorMessageVar] [number errorNumberVar] [from offendingObjectVar]
                     [to expectedTypeVar] [partial result resultListVar] sep
                     [varDeclarationList sep]
                     blockBody?)?
                 end [error|try] {pin=1}
//{recoverWhile=tryRecover}

varDeclarationListPart ::= identifier
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponent"
 implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"}

varDeclarationList ::= varAccessDeclaration (COMMA varDeclarationListPart)*

private errorMessageVar ::= directParameterDeclaration
private errorNumberVar ::= directParameterDeclaration
private offendingObjectVar ::= directParameterDeclaration
private resultListVar ::= directParameterDeclaration
private expectedTypeVar ::= directParameterDeclaration

private tellStatement ::= parseTellSimpleStatement|<<parseTellCompoundStatement>>

//see <<parseTellCompoundStatement>>
tellCompoundStatement ::= tell objectReferenceWrapper sep
                                        blockBody?
                          end [tell] //{pin=6}
{implements="com.intellij.plugin.applescript.psi.sdef.ApplicationDictionaryDeclarator"
 methods=[getApplicationName /*getApplicationReference*/]}
//                      {recoverWhile="tellRecover"}
//tellRecover ::= !(sep)

consideringStatement ::= considering considerOrIgnoreAttr ((COMMA considerOrIgnoreAttr)* (LAND considerOrIgnoreAttr)?)?
                           [but ignoring considerOrIgnoreAttr ((COMMA considerOrIgnoreAttr)* (LAND considerOrIgnoreAttr)?)? ] sep
                           blockBody?
                         end considering {pin=2}

ignoringStatement ::= ignoring considerOrIgnoreAttr ((COMMA considerOrIgnoreAttr)* (LAND considerOrIgnoreAttr)?)?
                        [but considering considerOrIgnoreAttr ((COMMA considerOrIgnoreAttr)* (LAND considerOrIgnoreAttr)?)? ] sep
                           blockBody?
                      end ignoring {pin=2}
private considerOrIgnoreAttr ::= expression

withTimeoutStatement ::= with timeout [of] timeoutIntegerExpression (seconds|second) sep
                           blockBody?
                         end [timeout] {pin=2}
private timeoutIntegerExpression ::= expression

withTransactionStatement ::= with transaction [sessionSpecificator] sep
                               blockBody?
                             end [transaction] {pin=2}
private sessionSpecificator ::= expression//referenceIdentifier

useStatement ::= useAppleScriptStatement|useApplicationOrScriptStatement|useFrameworkStatement
{implements="com.intellij.plugin.applescript.psi.sdef.ApplicationDictionaryDeclarator"
 methods=[getApplicationName useStandardAdditions withImporting]}
//todo 'considering numeric strings'

private useAppleScriptStatement ::= use 'AppleScript' [version expression] {pin=2}

private useScriptingAdditionsStatement ::= use SCRIPTING_ADDITIONS
                                   [((with importing)|(without importing)|importing) expression ] {pin=2}

//todo handle application id "stringWithId"
//use application "com.microsoft.Word" i.e. should not find application with such name -> create new map for app id
//see <<parseUseApplicationOrScriptStatementInner>>
private useApplicationOrScriptStatement ::= use [directParameterDeclaration COLON]
                    (
                     (   <<parseUsedApplicationNameExternal withImportCondition>>//application "string" &(importing)
                      |
                         dataSpecifier
                      |
                        (script dataSpecifier)
                     )
                        [versionSpecifier] [(with importing)|(without importing)|(importing expression)]
                    )

private withImportCondition ::= &([versionSpecifier] !((without importing)|(importing false)))
private dataSpecifier ::= expression//referenceExpression|stringLiteralExpression
private versionSpecifier ::= version stringLiteralExpression

private useFrameworkStatement ::= use framework dataSpecifier {pin=2}

//see <<parseUsingTermsFromStatement>>
usingTermsFromStatement ::= using terms from (applicationReference|(script dataSpecifier)|<<pushStdLibrary>>) sep
                             topBlockBody?
                            end [using terms from] //{pin=3}
{implements="com.intellij.plugin.applescript.psi.sdef.ApplicationDictionaryDeclarator"
 methods=[getApplicationName withImportingStdLibrary]}

//todo: to check com.jetbrains.python.psi.PyAssignmentStatement#getTargetsToValuesMapping
//and com.jetbrains.python.psi.impl.PyTargetExpressionImpl#findAssignedValue
//see also com.jetbrains.python.psi.impl.PyAssignmentStatementImpl#mapToValues
targetVariable ::= identifier
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponent"
implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"}

private ifStatement ::= ifCompoundStatement|ifSimpleStatement

ifSimpleStatement ::= if expression then (statement|expression)

ifCompoundStatement ::= if expression [then] sep
                                       blockBody?
                                   (else if expression [then] sep
                                       blockBody?  )*
                                   (else sep
                                        blockBody? )?
                        end [if] {pin=8}

// value class types
private literalExpression ::=
              stringLiteralExpression
              |styledTextLiteralExpression
              //|built_in_type
              |numberLiteralExpression
              |dictionaryConstant
              |builtInConstantLiteralExpression
              |listLiteralExpression
              |recordLiteralExpression
              |<<parseExpression '"date"' dateLiteralExpression>>
              |aReferenceToLiteralExpression

/** Numeric, string, regexp, boolean, date, string(space,tab,return) constant*/
builtInConstantLiteralExpression ::= boolean_constant|date_time_constants|text_constant|itMeProperty
|currentApplicationConstant| missing_value_constant | scriptingAdditionsFolderConstant
//|appleScriptPropertiesConstant
private scriptingAdditionsFolderConstant ::= SCRIPTING_ADDITIONS

dictionaryConstant ::= <<parseDictionaryConstant>>
{mixin="com.intellij.plugin.applescript.psi.sdef.impl.AbstractDictionaryConstantSpecifier"
 implements="com.intellij.plugin.applescript.psi.sdef.DictionaryCompositeElement"}

// SIMPLE literals

// Number class<<
numberLiteralExpression ::= realLiteralExpression|integerLiteralExpression|numericConstant

// >>Integer class<<
integerLiteralExpression ::= DIGITS

// A value of class Class is a class identifier. A class identifier is a reserved word that specifies the class
// to which an object or value belongs. The Class property of an object contains a class identifier value.
// >>Class class<<
builtInClassIdentifier ::= builtInClassIdCommon|builtInClassIdNative|script

//there is no need to define in SDEF these classes:
private builtInClassIdNative::= ANY|BOOLEAN|DATE|FILE|INTEGER|LOCATION_SPECIFIER|NUMBER|POINT|REAL|RECORD|RECTANGLE|
SPECIFIER|TEXT|TYPE|ALIAS

private builtInClassIdCommon::= STRING|CLASS|CONSTANT|LIST|DATA|REFERENCE|STYLED_TEXT|TEXT_ITEM|ITEM|FILE_SPECIFICATION|
INTERNATIONAL_TEXT|RGB_COLOR|STYLED_CLIPBOARD_TEXT|UNICODE_TEXT|unitTypeValueClasses

private unitTypeValueClasses ::= Length|SQUARE_AREA|CUBIC_VOL|LiquidVolume|Weight|TEMPERATURE
private Weight ::= GRAMS|KILOGRAMS|OUNCES|POUNDS
private LiquidVolume ::= GALLONS|LITRES|LITERS|QUARTS
private Length ::= CENTIMETRES|CENTIMETERS|FEET|INCHES|KILOMETRES|KILOMETERS|METRES|METERS|MILES|YARDS

//these classes are not found in standard additions:
//but declared as properties...
//private parseBuiltInClassIdentifierPlural ::= <<parseBuiltInClassIdentifierPluralInner>>
builtInClassIdentifierPlural ::= BUILT_IN_TYPE_S|scripts
dictionaryClassIdentifierPlural ::= <<parseDictionaryClassName true useStatementsCondition>>
{mixin="com.intellij.plugin.applescript.psi.sdef.impl.AbstractDictionaryClassSpecifier"
 implements="com.intellij.plugin.applescript.psi.sdef.DictionaryCompositeElement"}

//>>Real class<<
realLiteralExpression ::= ('.'(DIGITS)(DEC_EXPONENT))|(dec_significand DEC_EXPONENT?)
private dec_significand ::= ('.'DIGITS)|(DIGITS'.'DIGITS*)

// >>Date class<<
dateLiteralExpression ::= date (stringLiteralExpression|expression)
//private currentDateCommand ::= CURRENT_DATE

//>> List reference
//private list_specifier ::= (class|length|rest|reverse) of list_literal_expression // ref by properties
//                            item [index]
//A value of class Constant is a reserved word defined by AppleScript or an application in its dictionary.
// Applications define sets of values that can be used for parameters of a particular command. For example,
// the value of the saving parameter of a Close command must be one of the three constants yes, no, and ask
//For a complete listing of the constants AppleScript provides, see Table A-3(page 358) and Table A-2 (page 355).
// !! NOT CASE SENSITIVE !!
//You cannot define your own constants; constants can be defined only by applications and AppleScript.

textItemDelimitersProperty ::= TEXT_ITEM_DELIMETERS

//>>Record class<<
recordLiteralExpression ::= LCURLY[objectPropertyDeclaration] (COMMA objectPropertyDeclaration)* RCURLY//(BAND nls primaryExpression)*

targetRecordLiteral ::= LCURLY[objectTargetPropertyDeclaration] (COMMA objectTargetPropertyDeclaration)* RCURLY
{ methods=[getTargets] }
//todo inspection for only unique property label names

//>>String class<<
stringLiteralExpression ::= STRING_LITERAL

//>>List class<<
listLiteralExpression ::= LCURLY [expression] (COMMA expression)* RCURLY

targetListLiteral ::= LCURLY [targetVariablePattern|expression] (COMMA targetVariablePattern|expression)* RCURLY //{pin=4}
{methods = [getTargets] }

//The class identifier Styled Text is a synonym for a string that includes style and font information.
//>>Styled Text class<<
private styledTextLiteralExpression ::= STRING_LITERAL

//You can use the class identifier Text as a synonym for the identifier String
//>>Text class<<
//private text_literal ::= string_literal

// >>Boolean class<<
private boolean_constant ::= true|false

// COMMANDS
// commands  is a word or a series of words used in AppleScript statements to request an action.
// we need to parse xml files -> index command names and signatures they have -> after user inters some command

//An AppleScript command is one that is built into the AppleScript language. There currently are five such
// commands: get , set, count, copy, and run.
// Except for copy , each of these commands can also be implemented by applications.

/**
todo refactor application reference parsing rule so to insert and use anywhere in the
grammar: (tell/using terms/use statements). in general place do not push any app names, but redefine it for
each specific case: tell/use/using.
Examples:
tell application "App name" .. end tell
tell scripting additions ..end tell
use application "App name"
use scripting additions
using terms of application "App Name" end using terms of

<<parseApplicationName isCompoundStatement

The same for script reference:
tell script "Name" ... end tell
use script "Name"
*/
applicationReference ::= applicationName
[of THE_KW? machine machineName (of THE_KW? zone appleTalkZoneName)?] | THE_KW? currentApplicationConstant
{methods=[getApplicationName]}
private applicationName ::= <<parseApplicationName tellStatementStartCondition>> //id? STRING_LITERAL

private machineName ::= STRING_LITERAL
private appleTalkZoneName ::= STRING_LITERAL
private tellStatementStartCondition ::= <<isTellStatementStart>>

private handlerInterleavedCallOrPropertyReferenceOrReferenceIdentifier ::= handlerInterleavedParametersCall |
propertyReference | (referenceIdentifier handlerPositionalParametersCallExpression?)

//text itemS of item => could be plural class names here also
propertyReference ::=  dictionaryPropertyName|literalExpression|appleScriptProperty|builtInClassProperty

//todo check for longest match + check if inside tell stmt AND there is a class with
// longer matching name -> do not parse as a property
// !! + check the position -> priority to class name or command name if there is no (of|in) before and after
//todo do not check here for application classes! do it (if necessary) where the rule is used
dictionaryPropertyName ::=  (<<parseDictionaryPropertyName>> &(of|in|COLON))//(assertPropertyCondition <<parseDictionaryPropertyName>>)
                           |(!dictionaryClassName <<parseDictionaryPropertyName>>)
{mixin="com.intellij.plugin.applescript.psi.sdef.impl.AbstractDictionaryPropertySpecifier"
implements="com.intellij.plugin.applescript.psi.sdef.DictionaryCompositeElement"}

private builtInClassProperty ::= stringProperty | BUILT_IN_PROPERTY |
(&(builtInClassIdentifier of) builtInClassIdentifier) //this way or manually write all possible properties

private stringProperty ::= QUOTED_FORM

private propertyLabelIdentifier ::= propertyReference|identifier

arbitraryReference ::= some typeSpecifier {pin=1}

everyElemReference ::= every typeSpecifier | pluralClassName//{pin=1}

//The Filter reference form specifies all objects in a container that match one or  more conditions specified
// in a Boolean expression.
left filterReference ::=  (whose|where) expression

//The ID reference form specifies an object by the value of its ID property
left idReference ::= id expression

//The Index reference form specifies an object or a location by describing its position with respect
// to the beginning or end of a container. For related information, see “Relative” (page 185).
//todo change to expression !
private indexValueExpression ::= referenceIdentifier|integerLiteralExpression|parenthesizedExpression

indexReference ::=  (integerLiteralExpression('st'|'rd'|'th') (typeSpecifier|userClassName))
                   |((first|second|third|fourth|fifth|sixth|seventh|eighth|ninth|tenth) (typeSpecifier|userClassName) )
                   |((last|front|back) (typeSpecifier|userClassName)) //could userClassname be even theoretically??
//first need to check that this is not a property name
//things like: "message id of message" and "item i of EmailAddresses" _property_(1st) vs _index_(2nd) forms
// mailbox "Name string" detected as a 'mailbox' propertyReference
//todo: custom parsing. To think how more efficient handle propertyName vs className detection
//todo add predicate check to all dictionary terms parsing rules:
//todo if toldApplicationName is not empty - check all terms from there first(property,class,constant,command)
private classNamePrimaryExpression ::= typeSpecifier //!(of|in|COLON)
//private classNamePrimaryExpression ::= !(<<parseDictionaryPropertyName>> (of|in|COLON|!([index] indexValueExpression
//|nameReferenceString|rangeReferenceFormWithClassPrefix) ) ) typeSpecifier
// to think how better parse properties & class names
//private parseClassNameExpression ::= <<parseClassNamePrimaryExpression>>  //!(propertyReference (of| !([index] indexValueExpression)) ) typeSpecifier
//see <<parseClassNamePrimaryExpression>>
//classNamePrimaryExpression ::= !(propertyReference (of| !([index] indexValueExpression)) ) typeSpecifier

left indexReferenceClassForm ::= [index] indexValueExpression

private useStatementsCondition ::= <<parseCheckForUseStatements>>

dictionaryClassName ::= <<parseDictionaryClassName false useStatementsCondition>>
{mixin="com.intellij.plugin.applescript.psi.sdef.impl.AbstractDictionaryClassSpecifier"
 implements="com.intellij.plugin.applescript.psi.sdef.DictionaryCompositeElement"}

userClassName ::= identifier
{mixin="com.intellij.plugin.applescript.psi.impl.AppleScriptReferenceElementImpl"
implements="com.intellij.plugin.applescript.psi.AppleScriptReferenceElement"}

middleElemReference ::= middle typeSpecifier {pin=1}

left nameReference ::= nameReferenceString //could be any expression (clashed with indexReference)

private nameReferenceString ::= [named] nameStringExpression
private nameStringExpression ::= stringLiteralExpression//|parenthesized_expression //(smth as string) or get the string from some val

//rangeReference ::= everyRangeReference | rangeReferenceFormWithClassPrefix
private rangeReferenceFormWithClassPrefix ::= rangeFromReference | rangeIndexReference
rangeFromReference ::= /*(pluralClassName|userClassName)*/ from [THE_KW] (beginning|expression) to [THE_KW](end|expression)
rangeIndexReference ::= /*(typeSpecifier|userClassName)*/  startIndex (thru|through) stopIndex
everyRangeReference ::= every (singularClassName|userClassName) from (beginning|expression) to (end|expression)

private stopIndex::= integerLiteralExpression | expression
private startIndex ::= integerLiteralExpression | expression

relativeReference ::=  relativeBeforeReference | relativeAfterReference

private relativeBeforeReference ::= (before|([in] ( front | beginning ) of) )referenceExpression
private relativeAfterReference ::= (after|([in]( back | end ) of)|behind )referenceExpression
// >>Reference class<<
//private aRefTo ::= 'a reference to'|'a ref to'|'a ref'|'reference to'|'ref'
aReferenceToLiteralExpression ::= REF_OP objectReferenceWrapper //referenceExpression
// <<//A value of class Reference is a reference to an object. A reference can refer to an application object
// such as a window or file, or to an AppleScript object such as an item in a list or a property in a record.
// You can create a value of class Reference by using the A Reference To operator. In addition, applications can
// return references in response to commands.
// !!! A value of class Reference created with the A Reference To operator is a structure within AppleScript
// that refers to (or points to) a specific object. !!! a pointer!
// Values of class Reference are similar to pointers in other programming languages, but unlike pointers,
// references can refer only to objects.

//===Coercion (Object Conversion)===
// Coercion (also known as object conversion) is the process of converting objects from one class to another.
// AppleScript converts an object to a different class in either of these circumstances:
//- in response to the as operator
//- automatically, when an object is of a different class than was expected for a particular command or operation

private propertyDeclarationStatement ::= scriptPropertyDeclaration//|objectPropertyDeclaration
//{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponentplements="com.intellij.plugin.applescript.psi.AppleScriptComponent"

varAccessDeclaration ::= variableGlobalDeclaration|variableLocalDeclaration
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponent"
implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"}

//AppleScript propertyDeclaration
scriptPropertyDeclaration ::= (property|prop) propertyLabelIdentifier COLON propertyInitializerExpression
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponent"
implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"}

//Object (AppleScript record or application object) propertyDeclaration
//todo implement getIdentifier() method
objectPropertyDeclaration ::= propertyLabelIdentifier COLON propertyInitializerExpression
//{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponentnent"
//implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"}

//identifier could consist from several identifiers (in case of dictionary property)
objectTargetPropertyDeclaration ::= propertyLabelIdentifier COLON (targetVariablePattern|propertyInitializerExpression)
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponent"
implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"}

private variableGlobalDeclaration ::= global identifier
private variableLocalDeclaration ::= local identifier

private propertyInitializerExpression ::= expression
//An expression is any series of lexical elements that has a value. Expressions are used in scripts to represent
// or derive values. The simplest kinds of expressions, called literal expressions, are representations of values
// in scripts. More complex expressions typically combine literals, variables, operators, and object specifiers.
expression ::= logicalOrExpressionWrapper

parenthesizedExpression ::= LPAREN expressionInParentheses RPAREN

private expressionInParentheses ::= ( statement | expression )

// ===CONSTANTS===
// some of the constants (which are not expressions and are not evaluated at runtime should be
// written as lexer tokens
// constant expressions (like 'current application' constant whoch is an object specifier)
// probably should be written as predefined A.Script. expressions
// should we divide parsed constant expressions by types (boolean_constant|number_constant|
// text_constant|consider_ignore_attributes|... etc) and then insert them in expressions where appropriate?
// page 100
//pi|space|tab|linefeed|quote| //!return!
// all constant expressions we could specify in the among all other expressions => it will be valid

numericConstant ::= PI_CONSTANT|seconds_constants
private seconds_constants ::= MINUTES_CONSTANT|HOURS_CONSTANT|DAYS_CONSTANT|WEEKS_CONSTANT
private date_time_constants ::= weekday_constant|month_constant//seconds_constants to number_constants
private weekday_constant ::= 'Monday'|'Tuesday'|'Wednesday'|'Thursday'|'Friday'|'Saturday'
                            |'Sunday'|'Mon'|'Tue'|'Wed'|'Thu'|'Fri'|'Sat'|'Sun'
private month_constant ::= 'January'|'February'|'March'|'April'|'May'|'June'|'July'|'August'|'September'|'October'
                    |'November'|'December' |'Jan'|'Feb'|'Mar'|'Apr'|'Jun'|'Jul'|'Aug'|'Sep'|'Oct'|'Nov'|'Dec'

private currentApplicationConstant ::= CURRENT_APPLICATION|CURRENT_APP|(CURRENT APPLICATION) //'current application'|'current app'//current applicationClass
private missing_value_constant ::= MISSING_VALUE
//private save_opt_constant ::= yes|no|ask
private text_constant ::=  return|space|tab|linefeed|quote
private anythingProperty ::= anything
private resultProperty ::= result
private parentProperty ::= parent
private versionProperty ::= version

//todo redefine necessary methods (is property, getName etc.)
appleScriptProperty ::= BUILT_IN_PROPERTY|resultProperty|versionProperty|anythingProperty
|textItemDelimitersProperty|parentProperty//|itMeProperty//|text_constant /*?? */

private itMeProperty ::= it|me
//todo add via regexp (spaces)
handlerParameterLabel ::= about|above|against|'apart from'|around|'aside from'|at|below|beneath|beside|between|by|for
|from|'instead of'|into|on|onto|'out of'|over|since|thru|through|under|to //there is no 'to' label in documentation but it works!

argumentSelector ::= identifier COLON
{methods=[getSelectorIdentifier getSelectorName]}

//private handlerNamePartReference ::= referenceIdentifier //|propertyLabelComponent
//An identifier for the direct parameter variable. If it is included, directParamName must be listed immediately
// after the command name. The word of or in before directParamName is required in user-defined handlers,
// but is optional in terminology-defined handlers (for example, those defined by applications).
private userParameterVar ::= THE_KW? targetVariablePattern /// instead of componentName
private userLabelReference ::= THE_KW? referenceIdentifier

//===HANDLERS===
// handler is a collection of statements which can be invoked by name
//todo consider add all in handlerLabeledParametersDefinition and handledLabeledParametersName
handlerRunDefinition ::= on run directParameterDeclaration? sep
                            blockBody?
                          end run {pin=2}

handlerOpenDefinition ::= on open directParameterDeclaration? sep
                            blockBody?
                          end open {pin=2}

//handlerIdleDefinition ::= on idle nls
//                            blockBody? nls
//                           end idle {pin=2}

//handlerQuitDefinition ::= on quit nls
//                            blockBody? nls
//                           end quit {pin=2}
applicationHandlerDefinition ::= (on|to) applicationHandlerDefinitionSignature
                                         [given THE_KW? objectTargetPropertyDeclaration (COMMA THE_KW? objectTargetPropertyDeclaration)*] //nls //should be sep here
                                         [varDeclarationList] sep
                                           blockBody?
                                  end [applicationHandlerDefinitionSignature]
private applicationHandlerDefinitionSignature ::= <<parseApplicationHandlerDefinitionSignature>>
//private dictionaryCommandNameIdentifier ::= <<parseDictionaryCommandNameIdentifier>>

handlerLabeledParametersDefinition ::= (on|to) identifier !LPAREN labeledParameterDeclarationList
                                         [given THE_KW? objectTargetPropertyDeclaration (COMMA THE_KW? objectTargetPropertyDeclaration)*] //nls //should be sep here
                                         [varDeclarationList] sep
                                           blockBody?
                                        end [referenceIdentifier]
//                                        {pin=2}
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponent"
implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"
methods=[getParameterComponentList]}

labeledParameterDeclarationList ::= ((of|in) directParameterDeclaration)? labeledParameterDeclarationPart*
{methods=[getComponentList]}

directParameterDeclaration ::= THE_KW? identifier
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponent"
implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"}

labeledParameterDeclarationPart ::= handlerParameterLabel THE_KW? identifier //userParameterVar //todo implement targetVariablePattern here !!!
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponent"
implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"}

//private handlerNameStrict ::=(referenceIdentifier !handlerParameterLabel)*

//todo may be include these keywords on the top level script only not for the all the expressions...??
//todo should we made it left associative with identifier only??
//handlerLabeledParametersCall ::= handlerWithDirectLabeledParametersCall|handlerNoDirectLabeledParametersCall
left handlerLabeledParametersCallExpression ::=
   (
   (of|in) directParameterVal// on|of is mandatory if parsing user handler call
   (
     (    (handlerParameterLabel parameterVal)+
           ( (with labelForTrueParam (COMMA labelForTrueParam)* [(LAND|LOR|COMMA) labelForTrueParam])
           | (without labelForFalseParam (COMMA labelForFalseParam)* [(LAND|LOR|COMMA) labelForFalseParam])
           | (given userLabelReference COLON userParameterVal (COMMA userLabelReference COLON userParameterVal)*)
           )*
     )
     |
       ( (with labelForTrueParam (COMMA labelForTrueParam)* [(LAND|LOR|COMMA) labelForTrueParam])
       | (without labelForFalseParam (COMMA labelForFalseParam)* [(LAND|LOR|COMMA) labelForFalseParam])
       | (given userLabelReference COLON userParameterVal (COMMA userLabelReference COLON userParameterVal)*)
       )+
   )
   )|
   (
   (handlerParameterLabel parameterVal)+ //&(with|without|given)
       ( (with labelForTrueParam (COMMA labelForTrueParam)* [(LAND|LOR|COMMA) labelForTrueParam])
       | (without labelForFalseParam (COMMA labelForFalseParam)* [(LAND|LOR|COMMA) labelForFalseParam])
       | (given userLabelReference COLON userParameterVal (COMMA userLabelReference COLON userParameterVal)*)
       )*
   )

private parameterValue ::= expression
commandParameterSelector ::= <<parseCommandParameterSelector>>
//see
commandParameter ::= given? commandParameterSelector parameterValue
{mixin="com.intellij.plugin.applescript.psi.sdef.impl.AbstractAppleScriptCommandParameter"
implements="com.intellij.plugin.applescript.psi.sdef.AppleScriptCommandHandlerParameter"}
//private commandParameters ::= ( ((with|without) commandParameterSelector) | commandParameter )*
//commandParameterSelector ::= <<parseCommandParameterSelector>>

private labelForTrueParam ::= expression //referenceIdentifier
private labelForFalseParam ::= expression //referenceIdentifier

parameterVal ::= referenceIdBeforeParamLabel | expression

//sayHello to name -> only if referenceIdentifier followed by 'to'
private referenceIdBeforeParamLabel ::= referenceIdentifier &handlerParameterLabel

private userParameterVal ::= expression

//todo replace to just expression, add custom parsing ?
directParameterVal ::=  referenceIdBeforeParamLabel | expression

private parseTellSimpleStatement ::= <<parseTellSimpleStatementInner>>
//see <<parseTellSimpleStatementInner>>
//todo:restrict handler labeled call before to unless it is not parenthesizedExpression
//tellSimpleStatement ::= tell (referenceIdBeforeParamLabel | objectReferenceWrapper )
tellSimpleStatement ::= tell <<parseTellSimpleObjectReference>>
to (statement | handlerInterleavedParametersCall | expression )
{implements="com.intellij.plugin.applescript.psi.sdef.ApplicationDictionaryDeclarator"
 methods=[getApplicationName]}

handlerPositionalParametersDefinition ::= (on|to) identifier LPAREN [formalParameterList] RPAREN
                                            [varDeclarationList] sep
                                               blockBody?
                                            end [referenceIdentifier]
//                                            {pin=3  //or Grammar kit will also make formalParameterList as Component
//                                            }
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponent"
implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"}


//handlerPositionalParametersCallExpression ::= &(referenceIdentifier LPAREN) referenceIdentifier LPAREN argumentList? RPAREN
left handlerPositionalParametersCallExpression ::= LPAREN argumentList? RPAREN

formalParameterList ::= formalParameterListPart (COMMA formalParameterListPart)* //{recoverWhile="argument_list_recover"}
{ methods = [getFormalParameters] }

//todo впринципе можно тоже сделать это namedElement чтобы проще отображать в structureView
private formalParameterListPart ::= formalParameterListPartPattern {recoverWhile="argListPartRecover"}
//private formalParameterListPart ::= targetVariablePattern {recoverWhile="argument_list_part_recover"}
private argumentList ::= argumentListPart (COMMA argumentListPart)* {recoverWhile="argListRecover"}
private argListRecover ::= !(RPAREN)
private argumentListPart ::= statement | expression {recoverWhile="argListPartRecover"}
private argListPartRecover ::= !(RPAREN|COMMA)

private formalParameterListPartPattern ::= simpleFormalParameter|listFormalParameter|recordFormalParameter
listFormalParameter ::= LCURLY [formalParameterListPartPattern|expression] (COMMA formalParameterListPartPattern|expression)* RCURLY //{pin=4}
{methods = [getParameters] }

recordFormalParameter ::= LCURLY[objectNamedPropertyDeclaration] (COMMA objectNamedPropertyDeclaration)* RCURLY
{methods = [getParameters] }

objectNamedPropertyDeclaration ::= propertyLabelIdentifier COLON (formalParameterListPartPattern|propertyInitializerExpression)
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponent"
implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"}

simpleFormalParameter ::= THE_KW? identifier
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptComponent"
implements="com.intellij.plugin.applescript.psi.AppleScriptComponent"}

handlerInterleavedParametersDefinition ::= (on|to) handlerInterleavedParametersSelectorPart+ sep
                                               blockBody?
                                             end [handlerNamePartRef COLON (handlerNamePartRef COLON)*]
{mixin="com.intellij.plugin.applescript.psi.impl.AppleScriptHandlerInterleavedParameters"
implements="com.intellij.plugin.applescript.psi.AppleScriptHandler"}

private handlerNamePartRef ::= referenceIdentifier

//todo change to a named element (but is named element - it is not selected by resolver...)
handlerInterleavedParametersSelectorPart ::= selectorId COLON userParameterVar
 //todo or remove component name from here at all, or other things to try (several componentNames etc)?
{mixin="com.intellij.plugin.applescript.psi.impl.AppleScriptHandlerSelectorPartImpl"
implements="com.intellij.plugin.applescript.psi.AppleScriptHandlerSelectorPart"}

//this is needed so to redefine getIdentifier for handlerInterleavedParametersSelectorPart
selectorId ::= identifier


handlerInterleavedParametersCall ::= handlerArgument+
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptHandlerCall"
implements="com.intellij.plugin.applescript.psi.AppleScriptHandlerCall"}

handlerArgument ::= argumentSelector userParameterVal

scriptObjectDefinition ::= script scriptObjectName sep
                                  scriptBody?
                           end [script] //{pin=2}
{mixin="com.intellij.plugin.applescript.psi.impl.AbstractAppleScriptScriptObject"
implements="com.intellij.plugin.applescript.psi.AppleScriptScriptObject"}

scriptObjectUnnamedDefinition ::= script sep
                                  scriptBody?
                                 end [script] {pin=4}

private scriptObjectName ::= identifier

// http://hints.macworld.com/article.php?story=20050523140439734
continue_statement ::= continue expression


//===COMMANDS===
private appleScriptCommandExpression ::= getCommandExpression|runCommandExpression|countCommandExpression|
errorCommandExpression|logCommandExpression|activateCommandExpression|launchCommandExpression
//|runCommandExpression|errorCommandExpression//|setCommandSyntaxReturning
activateCommandExpression ::= activate expression?
launchCommandExpression ::= launch expression?

// standard built-in AppleScript commands
//There are only five AppleScript commands: Get, Set, Count, Copy, and Run.
//>>copy<<
private copyCommandStatement ::= (copy|put) expression (to|into) (targetVariablePattern|objectReferenceWrapper)

//>>count<<
// AppleScript syntax
countCommandExpression ::= (count [[each|every] typeSpecifier (in|of)] composite_value)
                        |(number of [typeSpecifier (in|of)] composite_value)

private typeSpecifier ::= pluralClassName|singularClassName
private pluralClassName ::= builtInClassIdentifierPlural|dictionaryClassIdentifierPlural //items?
private singularClassName ::= (dictionaryClassName|builtInClassIdentifier) ITEM?
private composite_value ::= expression

//>>get<<
// AppleScript syntax
//getCommandExpression ::= get expression
getCommandExpression ::= get <<parseCommandParametersExpression>>

//>>Run<< / Run Script
runCommandExpression ::= (run [script] [script_object_variable])|(run [referenceToApplicationVar]) // application command syntax
private referenceToApplicationVar ::= applicationReference
private script_object_variable ::= referenceIdentifier
// log - is a built into Script Editor command http://stackoverflow.com/a/21341372/2000323
logCommandExpression ::= log expression
//scriptObjectVariable A variable identifier whose value is a script object. This parameter is optional if the
// Run command is used within an appropriate Tell statement. Class: Script

//>>Set<<
//The AppleScript command assigns one or more values to one or more variables. It can also be used to share
// data among lists, records, or script objects—see the Notes section below and “Data Sharing” (page 206).
//todo and com.jetbrains.python.psi.impl.PyTargetExpressionImpl#findAssignedValue
//to check com.jetbrains.python.psi.PyAssignmentStatement#getTargetsToValuesMapping
//see com.jetbrains.python.psi.impl.PyAssignmentStatementImpl#mapToValues
private parseAssignmentStatement ::= <<parseAssignmentStatementInner>>
//see <<parseAssignmentStatementInner>>
assignmentStatement ::= setCommandAppleScript|copyCommandStatement
{methods=[getAssignmentTarget getTargets getTargetsToValuesMapping]}

//set AppleScript command
private setCommandAppleScript ::= setCommandAppleScriptSetSyntax|setCommandAppleScriptReturningSyntax
private setCommandAppleScriptSetSyntax ::= set THE_KW? (targetVariablePattern to|objectReferenceWrapper to) THE_KW? expression
//(( (&(targetVariablePattern to)targetVariablePattern) | objectReferenceWrapper ) to THE_KW? expression/*|expression*/) //{pin=1}//fall back to single expression=(
private setCommandAppleScriptReturningSyntax ::= expression returning targetVariablePattern
//The name of the variable in which to store the value, or a list of variable patterns,
//or a record of variable patterns. Class: Identifier, list, or record
private targetVariablePattern ::= targetVariable|targetListLiteral|targetRecordLiteral
//private referencePatternD ::= referenceExpression ((of|in|APS) THE_KW? referenceExpression)?// objectRef? //referenceExpressionD //variable reference /list of variable refs/record of refs


// OPERATORS & EXPRESSIONS
private logicalOrExpressionWrapper ::= logicalAndExpressionWrapper logicalOrExpression*
left logicalOrExpression ::= LOR NLS* logicalAndExpressionWrapper

private logicalAndExpressionWrapper ::= negationExpressionWrapper logicalAndExpression*
left logicalAndExpression ::= LAND NLS* negationExpressionWrapper

private negationExpressionWrapper ::= negationExpression | compareExpressionWrapper
negationExpression ::= (LNOT NLS* negationExpressionWrapper)

private compareExpressionWrapper ::= coercionExpressionWrapper compareExpression*
left compareExpression ::= (equalityOperator|relational_operator) NLS* coercionExpressionWrapper

private coercionExpressionWrapper ::= concatenationExpressionWrapper coercionExpression*
left coercionExpression ::= AS NLS* ( concatenationExpressionWrapper | typeSpecifier )

private concatenationExpressionWrapper ::= additiveExpressionWrapper concatenationExpression*
left concatenationExpression ::= BAND additiveExpressionWrapper

private additiveExpressionWrapper ::= multiplicativeExpressionWrapper additiveExpression*
left additiveExpression ::= (PLUS|MINUS) multiplicativeExpressionWrapper

private multiplicativeExpressionWrapper ::= powerExpressionWrapper multiplicativeExpression*
left multiplicativeExpression ::= multiplicativeOperator NLS* powerExpressionWrapper

private powerExpressionWrapper ::= objectReferenceWrapper powerExpression*
left powerExpression ::= POW objectReferenceWrapper

private prefixExpression ::= (prefixOperator prefixExpression) | valueExpression
private prefixOperator ::= PLUS|MINUS

private objectReferenceWrapper ::= THE_KW? prefixExpression objectReferenceExpression*//<<parseObjectReference>>*
//move down to primary? and add a check for possessive form to keep it uniform
private possessiveFormAndInterleavedCall ::= APS handlerInterleavedParametersCall

// custom parsing is needed not to parse as a labeled handler call: TELL referenceIdentifier's referenceIdentifier TO expression
// see <<parseObjectReference>>
left objectReferenceExpression ::=  ( possessiveFormAndInterleavedCall | objectPointer /*<<parseObjectReferencePointer>>*/
THE_KW? prefixExpression)
private objectPointer ::= of|in|APS
private valueExpression ::= primaryExpression filterReference?//coercionExpression*

dictionaryCommandHandlerCallExpression ::= <<parseCommandHandlerCallExpression>>
{mixin="com.intellij.plugin.applescript.psi.sdef.impl.AbstractAppleScriptCommandHandlerCall"
 implements="com.intellij.plugin.applescript.psi.sdef.AppleScriptCommandHandlerCall"}

//see parseCommandHandlerCallExpression
dictionaryCommandName ::= <<parseDictionaryCommandName>>
{mixin="com.intellij.plugin.applescript.psi.sdef.impl.DictionaryCompositeNameImpl"
implements="com.intellij.plugin.applescript.psi.sdef.DictionaryCompositeName"}

private primaryExpression ::=
     literalExpression
 |   dictionaryCommandHandlerCallExpression
 | ( referenceExpression
     ( <<isTreePrevSimpleReference>>
       (  handlerPositionalParametersCallExpression | <<isHandlerLabeledParametersCallAllowed>>  handlerLabeledParametersCallExpression )
     )?
   )
 |   parenthesizedExpression
 |   appleScriptCommandExpression

incompleteCommandHandlerCall ::= <<parseIncompleteCommandCall>>
{mixin="com.intellij.plugin.applescript.psi.sdef.impl.DictionaryCompositeNameImpl"
implements="com.intellij.plugin.applescript.psi.sdef.DictionaryCompositeName"}

// todo: left associate to class name (range, name, relative, index) ! checking that this is not a property first.. !
private referenceExpression ::= applicationReference | referenceForm | referenceIdentifier

private referenceForm ::=
      (my handlerInterleavedCallOrPropertyReferenceOrReferenceIdentifier )
    | (my?
    // it looks like only range reference can be compiled using referenceIdentifier. For other forms valid
    // class name is a must
       (classNamePrimaryExpression
        (  rangeReferenceFormWithClassPrefix
         | nameReference
         | relativeReference
         | indexReferenceClassForm
         | idReference
        )? //can not remove '?' from here.. as script compiles with just className as a primary expression...
       )
       |
       (  arbitraryReference
        | everyElemReference
        | everyRangeReference
        | middleElemReference
        | relativeReference
        | indexReference
        | propertyReference
       )
      )

private equalityOperator ::= NE|EQ
private relational_operator ::= LT|GT|LE|GE|containment_start_end_operator|containment_any_part_operator

// List and String
private containment_start_end_operator ::= STARTS_BEGINS_WITH|ENDS_WITH
//List, Record, String
private containment_any_part_operator ::= IS_CONTAIN|DOES_NOT_CONTAIN|IS_IN|IS_NOT_IN

private multiplicativeOperator ::= STAR|DIV|INT_DIV|MOD
